#!/usr/bin/env python3
"""
Lint helper for endurance archive plan CSV files.

The archive pipeline can emit a ``plan.csv`` describing archive/delete actions.
This script scans the plan for duplicate hashes and self-cancelling operations
so that retention policies can be reviewed quickly.
"""

from __future__ import annotations

import argparse
import csv
import sys
from collections import Counter, defaultdict
from pathlib import Path
from typing import Dict, Iterable, List, Sequence, Tuple


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Identify redundant entries in endurance archive plan CSV files."
    )
    parser.add_argument(
        "plans",
        nargs="+",
        help="One or more plan.csv files generated by archive_coupled_constraint_endurance.py.",
    )
    parser.add_argument(
        "--fail-on-duplicates",
        action="store_true",
        help="Exit with status 1 when duplicate hashes are detected.",
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress detailed output; only the exit status reflects findings.",
    )
    parser.add_argument(
        "--max-delete",
        type=int,
        help="Fail when delete actions exceed the given count.",
    )
    parser.add_argument(
        "--max-delete-max-age",
        type=int,
        help="Fail when delete actions triggered by max-age pruning exceed the limit.",
    )
    parser.add_argument(
        "--max-delete-max-entries",
        type=int,
        help="Fail when delete actions triggered by max-entries pruning exceed the limit.",
    )
    return parser.parse_args(argv)


def read_plan(path: Path) -> List[Dict[str, str]]:
    try:
        with path.open("r", newline="", encoding="utf-8") as handle:
            reader = csv.DictReader(handle)
            return [dict(row) for row in reader]
    except FileNotFoundError as exc:
        raise RuntimeError(f"plan CSV not found: {path}") from exc


def group_by_hash(records: Iterable[Dict[str, str]]) -> Dict[str, List[Dict[str, str]]]:
    buckets: Dict[str, List[Dict[str, str]]] = defaultdict(list)
    for row in records:
        hash_value = (row.get("hash") or "").strip()
        if hash_value:
            buckets[hash_value].append(row)
    return buckets


def find_self_cancelling(records: Iterable[Dict[str, str]]) -> List[tuple[str, List[Dict[str, str]]]]:
    by_target: Dict[str, List[Dict[str, str]]] = defaultdict(list)
    for row in records:
        target = (row.get("target") or "").strip()
        if target:
            by_target[target].append(row)

    offenders: List[tuple[str, List[Dict[str, str]]]] = []
    for target, rows in by_target.items():
        has_archive = any(row.get("action") == "archive" for row in rows)
        has_delete = any(row.get("action") == "delete" for row in rows)
        if has_archive and has_delete:
            offenders.append((target, rows))
    return offenders


def describe_row(row: Dict[str, str]) -> str:
    action = row.get("action", "")
    reason = row.get("reason", "")
    detail = row.get("detail", "")
    return f"{action} (reason={reason or 'n/a'}, detail={detail or 'n/a'})"


def _summarise_actions(rows: List[Dict[str, str]]) -> Dict[str, int]:
    counts = Counter(row.get("action", "") for row in rows)
    delete_rows = [row for row in rows if row.get("action") == "delete"]
    return {
        "delete": len(delete_rows),
        "delete_max_age": sum(
            1 for row in delete_rows if "max-age" in (row.get("reason") or "")
        ),
        "delete_max_entries": sum(
            1 for row in delete_rows if "max-entries" in (row.get("reason") or "")
        ),
        "total": len(rows),
        "archive": counts.get("archive", 0),
    }


def lint_plan(path: Path, quiet: bool = False) -> Tuple[bool, Dict[str, int]]:
    rows = read_plan(path)
    duplicate_hashes = {
        hash_value: entries
        for hash_value, entries in group_by_hash(rows).items()
        if len(entries) > 1
    }
    self_cancelling = find_self_cancelling(rows)
    action_summary = _summarise_actions(rows)

    if quiet:
        return bool(duplicate_hashes or self_cancelling), action_summary

    print(f"=== {path} ===")
    if not rows:
        print("No entries found.")
    if duplicate_hashes:
        print(f"Duplicate hashes ({len(duplicate_hashes)} groups):")
        for hash_value, entries in duplicate_hashes.items():
            actions = ", ".join(describe_row(entry) for entry in entries)
            print(f" - {hash_value[:12]}â€¦ -> {actions}")
    else:
        print("No duplicate hashes detected.")

    if self_cancelling:
        print(f"Self-cancelling targets ({len(self_cancelling)}):")
        for target, entries in self_cancelling:
            actions = ", ".join(describe_row(entry) for entry in entries)
            print(f" - {target}: {actions}")
    else:
        print("No archive/delete overlaps detected.")
    print(
        f"Action summary: archive={action_summary['archive']} delete={action_summary['delete']} "
        f"(max-age={action_summary['delete_max_age']} max-entries={action_summary['delete_max_entries']})"
    )

    return bool(duplicate_hashes or self_cancelling), action_summary


def _threshold_violations(
    path: Path,
    summary: Dict[str, int],
    *,
    max_delete: int | None,
    max_delete_max_age: int | None,
    max_delete_max_entries: int | None,
) -> List[str]:
    issues: List[str] = []
    if max_delete is not None and summary["delete"] > max_delete:
        issues.append(
            f"{path}: delete actions {summary['delete']} exceed limit {max_delete}"
        )
    if max_delete_max_age is not None and summary["delete_max_age"] > max_delete_max_age:
        issues.append(
            f"{path}: max-age deletes {summary['delete_max_age']} exceed limit {max_delete_max_age}"
        )
    if max_delete_max_entries is not None and summary["delete_max_entries"] > max_delete_max_entries:
        issues.append(
            f"{path}: max-entries deletes {summary['delete_max_entries']} exceed limit {max_delete_max_entries}"
        )
    return issues


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    duplicates_found = False
    threshold_violations: List[str] = []

    for plan_path in args.plans:
        path = Path(plan_path).expanduser()
        has_duplicates, summary = lint_plan(path, quiet=args.quiet)
        duplicates_found = duplicates_found or has_duplicates
        threshold_violations.extend(
            _threshold_violations(
                path,
                summary,
                max_delete=args.max_delete,
                max_delete_max_age=args.max_delete_max_age,
                max_delete_max_entries=args.max_delete_max_entries,
            )
        )

    for issue in threshold_violations:
        print(f"Threshold violation: {issue}", file=sys.stderr)

    exit_due_to_thresholds = bool(threshold_violations)
    if (args.fail_on_duplicates and duplicates_found) or exit_due_to_thresholds:
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
