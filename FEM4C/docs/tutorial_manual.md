# FEM4C チュートリアルマニュアル（新版）
**MATLAB 利用者が C 言語で FEM ソルバーを実装するための完全教科書**

---

このマニュアルは、以下のサイクルを繰り返しながら学ぶ構成になっている。

1. **理論を整理する** – 最小限の数式と概念を確認する。  
2. **自分で実装する** – ヒントに従ってプラクティスコードを書き、手を動かす。  
3. **FEM4C を確認する** – 実コードの該当箇所を読み、自分の実装と照らし合わせる。  
4. **検証して理解を深める** – 小さな解析を走らせて結果を評価する。  

ゴールは **一次三角形要素 (T3) のソルバーを自作し、その知見をもとに FEM4C の二次三角形要素 (T6) を理解・拡張できるようになること**。  
学習者の前提は「FEM 理論の概要と MATLAB 経験はあるが、C での本格実装は初めて」である。

リポジトリには各章の練習用コードをまとめた `practice/` ディレクトリが同梱されている。`practice/README.md` で概要を確認しながら、提示された課題を自分の環境に合わせて改造していこう。

---

## 目次
1. [スタートガイド](#chapter-01)  
2. [FEM 理論の復習と実装戦略](#chapter-02)  
3. [T3 要素の形状関数とヤコビアン](#chapter-03)  
4. [T3 要素剛性マトリクスの生成](#chapter-04)  
5. [全体剛性マトリクスと境界条件](#chapter-05)  
6. [線形ソルバと検証（T3 完成）](#chapter-06)  
7. [T6 要素の理論と実装ポイント](#chapter-07)  
8. [T6 要素の剛性・荷重・検証](#chapter-08)  
9. [入力パーサーの実装ガイド](#chapter-09)  
10. [FEM4C の全体構成と次の一歩](#chapter-10)  
11. [付録](#appendix)

---

<a id="chapter-01"></a>
## Chapter 01. スタートガイド

### 理論を整理する
- FEM の離散化結果は `K d = f`。  
- 節点変位 `d` と外力 `f` を得ることで、応力・反力・変位が計算できる。  
- 要素ごとに局所座標で剛性を計算し、全体系にアセンブルするのが基本。

### 実装タスク（ヒント付き）
1. **環境準備**
   - `make openmp` が通ることを確認。  
   - `./bin/fem4c examples/t6_cantilever_beam.dat output.dat` を実行してログを保存。
2. **練習フォルダを参照**
   - リポジトリの `practice/ch01/hello.c` をビルドし、`gcc -Wall -Wextra practice/ch01/hello.c -o hello` で CLI の基本形を確認する。
     - `@HINT`: `-Wall` は代表的な警告をすべて出し、`-Wextra` はさらに細かい警告を追加するオプション。FEM 実装では配列境界や未初期化変数が致命的バグにつながるため、警告ゼロでビルドする習慣を最初から身につける。
   - このフォルダに各章のミニ実装を置いていく。

### FEM4C を読む
- `Makefile`：`openmp` ターゲットが `-fopenmp` を付けてビルドしていることを確認。  
- `README.md`：ビルド・実行手順の概要を把握する。

### 検証課題
- `practice/ch01/hello.c` を改造してコマンドライン引数（入力ファイル名）を表示させる。  
- `bin/fem4c` と同じ構成で実行できる CLI の基本形を掴む。

### 解析結果の確認と可視化
- `./bin/fem4c examples/t6_cantilever_beam.dat beam_output.dat` を実行し、`beam_output.{dat,csv,vtk,f06}` が生成されることを確認する。  
- CSV 出力は **21 列構成** で、`type,id,x,y,z,ux,uy,uz,disp_mag,n1,n2,n3,n4,n5,n6,sigma_x,sigma_y,tau_xy,von_mises,sigma_max,sigma_min` の順。  
  - `NODE` 行は座標・変位・変位量までが埋まり、`n1`〜`n6` など要素関連列は空欄。  
  - `ELEMENT` 行は `id` の後に 7 列分の空欄が入り、その後 `n1`〜`n6` → 応力値が並ぶ。  
- 解析後に Python で列数を検査するとフォーマットの崩れを早期発見できる。
  ```python
  import csv
  with open("beam_output.csv") as f:
      reader = csv.reader(f)
      header = next(reader)
      node = next(r for r in reader if r[0] == "NODE")
      elem = next(r for r in reader if r[0] == "ELEMENT")
      assert len(header) == len(node) == len(elem) == 21
  ```
- MATLAB で可視化する場合は `visualize_results.m` を実行する。`csvFile` 変数を上書きすると複数ケースを切り替えやすい。  
- ParaView 利用時は `beam_output.vtk` を読み込み、Warp By Vector（Displacement）→ 色付けに Von Mises を指定すると FEM4C 出力全体を俯瞰できる。

---

<a id="chapter-02"></a>
## Chapter 02. FEM 理論の復習と実装戦略

### 理論を整理する
- **最小ポテンシャルエネルギー原理**  
  - 全ポテンシャルエネルギー Π = U - W が最小になるときに平衡。  
  - U = 1/2 ∫ ε^T D ε dV、W = ∫ N^T f dV + ∫ N^T t dS。  
  - 離散化すると `K d = f` が得られる。
- **要素剛性マトリクス**  
  - `Ke = ∫ B^T D B det(J) dξ dη`（2D の場合）。  
  - **B マトリクス（ひずみ‐変位マトリクス）**: 節点変位ベクトル `d = [u1, v1, u2, v2, ...]^T` をひずみ `ε = [ε_xx, ε_yy, γ_xy]^T` に変換する行列。  
    ```
    ε = B d,
    ε_xx = Σ (∂Ni/∂x) ui,  ε_yy = Σ (∂Ni/∂y) vi,  γ_xy = Σ ((∂Ni/∂y) ui + (∂Ni/∂x) vi)
    ```
    という式を行列化したもので、要素形状（形状関数の偏微分）だけを含む。  
  - **D マトリクス（構成則マトリクス）**: 応力 `σ = [σ_xx, σ_yy, τ_xy]^T` とひずみの線形関係を表す材料行列。等方性平面応力なら  
    ```
    D = E/(1-ν^2) * [[1, ν, 0],
                     [ν, 1, 0],
                     [0, 0, (1-ν)/2]]
    ```
    となり、材料力学で学ぶ 2 次元フックの法則に対応する。材料特性（E, ν）をここに組み込む。  
  - **det(J)**: 自然座標と実座標の面積（体積）変換係数。要素形状が潰れていないか、節点順序が正しいかを判定する指標にもなる（負値やゼロに近い値は要注意）。

### 実装タスク（ヒント付き）
1. **理論メモ作成**  
   - ノートに「Π 最小 → Kd=f の導出」「B が幾何・D が材料・detJ が面積変換を受け持つ」ことを書き起こす。  
   - MATLAB で T3 要素の B・D を定義し、`Ke = ∫ B.'*D*B*detJ dξ dη` を Symbolic Toolbox で計算して結果を保存する。これが後で C 実装の検算に使える “正解表” になる。
2. **離散化結果の確認**  
   - `practice/ch02/penalty.c` をビルドし、1 次元のバネ 2 本を解析（剛性行列を手入力）。
   - 手計算・MATLAB・C の結果が一致するか確認。

### FEM4C を読む
- `docs/01_requirements.md`：求められている解析範囲を把握。  
- `docs/03_design.md`：モジュール分割の考え方を確認。

### 検証課題
- MATLAB で T3 の Ke を計算し、値を表にまとめる。  
- `practice/ch02/penalty.c` の結果と手計算を比較し、誤差がゼロになることを確認。

---

<a id="chapter-03"></a>
## Chapter 03. T3 要素の形状関数とヤコビアン

### 理論を整理する
- **バリセンター（面積座標）の考え方**: 任意の三角形内部の点は節点 1〜3 からの重み付き平均として表現でき、その重みが形状関数 `N1, N2, N3` に相当する。
  - `N1 = 1 - ξ - η`, `N2 = ξ`, `N3 = η`。自然座標 (ξ, η) の範囲は 0 ≤ ξ, η かつ ξ + η ≤ 1。
- **偏微分と幾何学的意味**: `∂Ni/∂ξ`, `∂Ni/∂η` は自然座標系での変化率。節点座標と組み合わせて `∂Ni/∂x`, `∂Ni/∂y` を求めることで、変位の勾配（＝歪み）を算出できる。
- **ヤコビアン J**: 
  ```
  J = [∂x/∂ξ  ∂x/∂η;
       ∂y/∂ξ  ∂y/∂η],   det(J) = (∂x/∂ξ)(∂y/∂η) - (∂x/∂η)(∂y/∂ξ)
  ```
  `det(J)` は自然座標面積から実座標面積へのスケール係数。正値であることが健全な要素の条件であり、負値は節点順序が反時計回りでないことを意味する。
- **勾配の変換**: 自然座標で求めた偏微分を実座標へ変換する公式
  ```
  [∂Ni/∂x, ∂Ni/∂y]^T = J^{-1} [∂Ni/∂ξ, ∂Ni/∂η]^T
  ```
  が離散化の基礎。これを全節点分まとめると B マトリクスの素材になる。

#### 簡易図: T3 要素の節点配置と自然座標
```
        η軸↑
            N3 (ξ=0, η=1)
             *
            / \
           /   \
          /     \
 N1 (ξ=0,η=0)*---* N2 (ξ=1,η=0)
             → ξ軸
```
図では頂点節点 (N1,N2,N3) を反時計回りに配置し、要素内部の任意点は自然座標 (ξ,η) の組で記述する。実座標 `(x,y)` は `x = Σ Ni xi`, `y = Σ Ni yi` の線形補間で得られる。detJ>0 となる節点順序を守ることが特徴づけの第一歩。

### MATLAB 演習
1. `syms xi eta` を使って `N1, N2, N3` を定義し、`diff` で `∂Ni/∂xi`, `∂Ni/∂eta` を計算する。行列 `dN_dxi`, `dN_deta` を作りノートに写す。
2. 節点座標を `[(0,0); (1,0); (0,1)]` として `J`, `detJ`, `dN/dx`, `dN/dy` を計算し、具体的な数値を記録する。
3. 任意点 (ξ,η)=(1/3,1/5) で形状関数と勾配を評価し、後で C 実装と比較する表を作成する。

### C 言語演習（ヒント付き）
1. **形状関数関数**: `practice/ch03/t3_shape.c` の `t3_shape_functions` 実装を読み、MATLAB で導いた式と照合する。必要に応じて自分で書き直した版を追加する。
2. **ヤコビアン計算**: 同ファイルの `t3_jacobian` をトレースし、行列積の流れをコメントでまとめる。@HINT: 行列要素をゼロ初期化してから節点ループで加算する。
3. **実座標偏微分**: `t3_shape_derivatives_global` の逆行列計算を確認し、`J^{-1}` を使って `dN/dx`, `dN/dy` を求める。@HINT: 2×2 逆行列は `(1/detJ)*[[ J22, -J12],[-J21, J11]]`。
4. MATLAB で作成した比較表を入力し、付属のテストコードを拡張して数値照合する。

### 検証課題
- (ξ,η)=(1/3,1/3) を入力したとき `N1=N2=N3=1/3` になるか自動テストを組む。
- 節点順序を入れ替えたとき detJ の符号がどう変化するかを検証し、不正要素の検出に活用できるか考える。
- 直角三角形と細長い三角形で `|detJ|` の大きさを比較し、B マトリクスの値や数値安定性への影響を評価する。
- 簡易図を見ながら、反時計回り配置を手書きし detJ>0 となる例／<0 となる例を整理し、図と照合して節点番号付けのルールを説明する。

### 応用例
- 形状関数を用いて節点値から要素内任意点の変位を補間する小さな関数を作成し、可視化に応用する。
- FEM4C が行っている要素健全性チェック（`t3_check_element_geometry`）を読み、detJ の符号と関連付けて説明できるようにする。

### FEM4C を読む
- `src/elements/t3/t3_element.c`
  - `t3_shape_functions` と `t3_jacobian_matrix` を確認。
  - どのように配列を再利用しているか観察。
### FEM4C を読む
- `src/elements/t3/t3_element.c`  
  - `t3_shape_functions` と `t3_jacobian_matrix` を確認。  
  - どのように配列を再利用しているか観察。

### 検証課題
- `xi = eta = 1/3` のとき `N1=N2=N3=1/3` になることを C/MATLAB 両方で確認。  
- 直角三角形と細長い三角形で detJ の違いを出力し、形状の影響を把握する。

### 応用例
- 要素内任意点の変位を補間するために形状関数を使えるようにする。  
- 節点順序が時計回りの場合に detJ が負になる理由を図で説明できるようにする。

---

<a id="chapter-04"></a>
## Chapter 04. T3 要素剛性マトリクスの生成

### 理論を整理する
- **B マトリクス（3×6 行列）**: 2D 平面応力では
  ```
  B = [∂N1/∂x  0        ∂N2/∂x  0        ∂N3/∂x  0;
       0        ∂N1/∂y  0        ∂N2/∂y  0        ∂N3/∂y;
       ∂N1/∂y  ∂N1/∂x  ∂N2/∂y  ∂N2/∂x  ∂N3/∂y  ∂N3/∂x]
  ```
  1 行目が xx ひずみ、2 行目が yy ひずみ、3 行目が xy せん断ひずみを節点変位 `d=[u1,v1,u2,v2,u3,v3]^T` から求める係数になる。
- **D マトリクス（材料行列）**: 等方性平面応力で
  ```
  D = E/(1-ν^2) * [[1, ν, 0], [ν, 1, 0], [0, 0, (1-ν)/2]]
  ```
  材料力学のフックの法則を行列表現したもの。平面ひずみの場合は分母 `(1+ν)(1-2ν)` になる点に注意。
- **要素剛性 `Ke`**: 
  ```Ke = ∫_Ωe B^T D B det(J) dξ dη ≈ Σ_{gp} B^T D B det(J) w_gp```
  T3 は線形要素なので 1 点積分（要素面積の中心）で正確な値が得られる。厚み `t` を掛け忘れないこと。

### MATLAB 演習
1. Chapter 03 で得た `dN/dx`, `dN/dy` を用いて B を symbolic に組み立てる。
2. 材料定数 `E`, `ν`, 厚み `t` を symbolic で定義し、`Ke = simplify(B.' * D * B * detJ * t)` を計算する。
3. 数値例（E=210e9, ν=0.3, t=1.0, 節点座標は単位三角形）を代入して数値 Ke を求め、後で C 実装と比較する表を作成する。

### C 言語演習（ヒント付き）
1. **B マトリクス関数**: `practice/ch04/t3_stiffness.c` の `t3_build_B` を追い、行列構造を紙に写して理解する。@HINT: 行列をゼロ初期化し、節点ループで該当項に代入する。
2. **D マトリクス関数**: 同ファイルの `plane_stress_D` を自分の値で試し、分母 `(1-nu*nu)` の扱いを確認する。
3. **要素剛性計算**: `t3_element_stiffness` をステップごとに追跡し、`BD = D * B` → `Ke = B^T * BD * detJ * t * weight` の流れを理解する。@HINT: 3×6 の一時配列を用意するとコードが読みやすい。
4. MATLAB の比較表を読み込み、付属テストに追加して行列要素ごとの差を出力する。差が 1e-10 以下になれば成功。

### 検証課題
- Ke に `[1,1,1,1,1,1]^T` を掛けたときに結果がほぼゼロになる（剛体モード）か確認する。
- 節点座標を変えて（例: 非直角三角形）もう一度 Ke を計算し、MATLAB と一致するか確認。
- `detJ` をゼロに近い値にして計算が不安定になる様子を観察し、要素品質の重要性を理解する。

### 応用例
- B と D を 3D ソリッド要素（6×(3n), 6×6）に拡張したとき行列サイズがどうなるか計算してみる。
- 片持ち梁 1 要素モデルで `K d = f` を解き、理論変位と比較するミニプログラムを作る。

### FEM4C を読む
- `src/elements/t3/t3_stiffness.c`（T3 実装）／`src/elements/t6/t6_stiffness.c`（T6 実装）
  - B・D 計算部分、厚み `thickness` の扱いを確認。
- `assembly_add_element_stiffness_t3` の DOF マップ処理を合わせて読む。
### FEM4C を読む
- `src/elements/t3/t3_stiffness.c`（ファイルがなければ T6 実装を参照）  
  - B・D 計算部分、厚みの扱いを確認。  
- `assembly_add_element_stiffness_t3` の DOF マップ処理を合わせて読む。

### 検証課題
- MATLAB で計算した Ke と C 実装の Ke を比較し、最大誤差が `1e-10` 以下になることを確認。  
- Ke に 1 のベクトルを掛けた結果がゼロになる（剛体モード）か検証。

### 応用例
- 片持ち梁 1 要素モデルで `K d = f` を解き、手計算の変位と比較する。  
- B・D を 3D に拡張するとどうなるか（行列サイズ）を考察する。

---

<a id="chapter-05"></a>
## Chapter 05. 全体剛性マトリクスと境界条件

### 理論を整理する
- **要素 → 全体系の組立**: 各要素剛性 `Ke` は局所自由度順 (例: [u1,v1,u2,v2,u3,v3]) で並んでいる。対応する全体系自由度 `global_dofs = [2*node_i, 2*node_i+1,...]` を使って `K(global_i, global_j) += Ke(i,j)` を行う。
- **荷重ベクトル f**: 要素荷重（体積力 or 表面力）を節点荷重に換算し、同じ DOF マッピングで加算する。点荷重は直接 RHS に入れる。
- **境界条件**:
  - Dirichlet（変位既知）：該当 DOF の行と列を 0 にし、対角成分を 1、右辺を既知変位に設定。これで方程式が SPD のまま保たれる。
  - Neumann（力既知）：荷重ベクトル f にそのまま加える。
- **チェックポイント**: 固定自由度が不足していると K が特異行列になる。解析前に拘束の数を確認する。

#### 簡易図: T3 要素 DOF と全体系インデックス
```
局所 DOF        対応節点        全体系DOF番号
-----------     -----------     ----------------
 u1, v1   ──→   node 0          0, 1
 u2, v2   ──→   node 1          2, 3
 u3, v3   ──→   node 2          4, 5

Ke(i,j) の寄与は K[global_dofs[i], global_dofs[j]] へ加算する。
```
アセンブリ時は対称性を保つよう、上三角・下三角の両方に値を足し込む実装が多い。

### MATLAB 演習
1. `Ke1`, `Ke2` など小さな要素剛性を MATLAB で用意し、対応する DOF マップを使って 4×4 や 6×6 の全体剛性を組むスクリプトを書く。
2. Dirichlet 境界条件を `K(fixed,:)=0; K(:,fixed)=0; K(fixed,fixed)=1; f(fixed)=u_fixed;` のように処理し、結果が安定するか確認する。
3. 小さなモデルで解析結果を求め、後で C で組むときの比較データにする。

### C 言語演習（ヒント付き）
1. **DOF マッピング関数**: `practice/ch05/assembly.c` の `map_t3_dofs` を読み、`dof_map[2*i] = node*2; dof_map[2*i+1] = node*2+1;` の規則を確認する。
2. **全体剛性の組立**: 同ファイルの `assemble` を動かし、密行列 `double K[6][6]` で DOF マップがどのように反映されるかを追う。@HINT: 境界チェックのために非対角要素も加算する。
3. **境界条件処理**: `apply_dirichlet` の行列操作を理解し、章冒頭のアルゴリズムと照合する。@HINT: 行・列を 0 にした後、対角と RHS を設定。
4. MATLAB で保存した結果と比較し、`max_abs_error < 1e-10` になるか確認するテストを追加。
5. 簡易図に記した局所 DOF ↔ 全体系インデックス表を参照しながら、別の節点番号セット（例: node 3,4,7）を用いたマップ表を自作し、`map_t3_dofs` の出力と一致するか確かめる。

### 検証課題
- 2 要素の片持ち梁（4 節点, 全体 DOF=8）の解析を自作コードで実行し、変位が MATLAB と一致するか調べる。
- Dirichlet 条件を外す（固定節点を減らす）と行列が特異になることを確認し、エラー処理を検討する。
- Neumann 条件だけで支えるケース（自由梁）で剛体モードが残ることを確かめ、境界設定の重要性を理解する。

### 応用例
- FEM4C のスカイライン行列を真似した簡易スカイライン実装を `practice` で試作し、密行列との性能差を測定する。
- 要素毎にアセンブリ時の寄与を `printf` で出力し、どの DOF に影響するか可視化する。

### FEM4C を読む
- `src/solver/assembly.c` の `assembly_get_element_dof_map`, `assembly_matrix_add_value`, `assembly_apply_boundary_conditions` を読み、自分の実装と比較する。
### FEM4C を読む
- `src/solver/assembly.c` の `assembly_get_element_dof_map`、`assembly_matrix_add_value`。  
- `assembly_apply_boundary_conditions` の処理を確認し、自作コードと比較する。

### 検証課題
- 2 要素の片持ち梁モデルで、自作コードと FEM4C の出力が一致するか確認。  
- 自作コードで `make` → `実行` → `結果表示` の一連の流れを整える。

### 応用例
- スカイライン行列（FEM4C の実装）と密行列の違いを整理する。  
- 固定節点が足りないと行列が特異になることを例で示す。

---

<a id="chapter-06"></a>
## Chapter 06. 線形ソルバと検証（T3 完成）

### 理論を整理する
- **共役勾配法 (CG)**: SPD 行列に対する反復法。基本ステップは
  ```
  r0 = b - A x0,   p0 = r0
  αk = (rk^T rk) / (pk^T A pk)
  x_{k+1} = x_k + αk pk
  r_{k+1} = r_k - αk A pk
  βk = (r_{k+1}^T r_{k+1}) / (rk^T rk)
  p_{k+1} = r_{k+1} + βk pk
  ```
  残差のノルムが所定の許容値を下回ったら収束とみなす。
- **収束の指標**: 片持ち梁などベンチマーク問題で理論変位 `δ = P L^3 / (3 E I)` を計算し、解析結果が収束しているかを評価する。
- **数値安定性**: 行列が特異・正定でない場合 CG は発散する。境界条件や DOF マッピングが正しいかを常にチェックする。

### MATLAB 演習
1. 小さな SPD 行列 `A` とベクトル `b` を用意し、MATLAB の `pcg(A,b)` で解を求める。反復数と残差を記録する。
2. T3 片持ち梁の全体行列・荷重を MATLAB で組み、小規模解析を実行。FEM4C や自作 C 実装と比較するための基準値 (`max displacement`, `reaction force`) を記録する。
3. CG の収束履歴（残差 vs iteration）をグラフ化し、初期残差の大きさや許容誤差によってどう変わるか観察する。

### C 言語演習（ヒント付き）
1. **CG の最小実装**: `practice/ch06/cg.c` の `cg_solve` を読み、初期残差・方向ベクトル・反復更新の流れを整理する。@HINT: 行列積ではスカイラインを意識しなくて良いので密行列で構わない。
2. **ログ機能**: 付属プログラムを拡張し、各 10 反復で残差を表示して収束状況を追跡する。@HINT: 第 1 反復で残差が減少しない場合は警告を出す。
3. **T3 ソルバー統合**: Chapter 05 までのコードに `cg_solve` を組み込み、T3 片持ち梁を C のみで解けるようにする。入力はハードコードで構わない。
4. MATLAB の基準値と比較し、最大変位や反力が 5% 以内に収束しているか確認する。

### 検証課題
- 自作 CG と MATLAB `pcg` の反復回数・残差を比較し、差が小さいことを確認する。
- 初期ベクトル `x0` を 0 ベクトルとランダムベクトルで変えて収束の違いを観察する。
- 許容誤差 `tol` を 1e-4, 1e-6, 1e-8 と変えて最終変位がどの程度変わるかを確認し、必要な精度を判断する。

### 応用例
- 残差履歴を CSV に出力し、Python や MATLAB で収束グラフを描画する。
- FEM4C の CG に対角前処理（Jacobi）を追加する際の変更点を調査し、設計メモを作成する。

### FEM4C を読む
- `src/solver/cg_solver.c` を読み、`cg_matrix_vector_multiply` がスカイライン行列をどう扱っているか確認。
- `static_analysis.c` のワークフロー（初期化 → 入力 → 解析 → 出力）を追い、自作コードとの対応関係をまとめる。
### FEM4C を読む
- `src/solver/cg_solver.c` を読み、`cg_matrix_vector_multiply` がスカイライン行列をどう扱っているか確認。  
- `static_analysis.c` のワークフロー（初期化 → 入力 → 解析 → 出力）も追う。

### 検証課題
- 自作 T3 ソルバーで UY の最大値が理論解と 5% 以内に収まるか確認。  
- FEM4C の T3/Q4/T6 解析結果とグラフで比較する。

### 応用例
- 自作コードに `csv` 出力を加え、変位プロファイルを可視化する。  
- 解析時間と反復回数を記録し、FEM4C のログと比較する。

---

<a id="chapter-07"></a>
## Chapter 07. T6 要素の理論と実装ポイント

### 理論を整理する
- **二次三角形要素 (T6)**: 三角形の各辺に中間節点を持つ 6 節点要素。形状関数は 2 次式で、端点では 1、その他では 0、辺上では線形補間になる性質を持つ。
- **形状関数の具体式**:
  ```
  zeta = 1 - ξ - η
  N1 = zeta (2 zeta - 1),  N2 = ξ (2 ξ - 1),
  N3 = η (2 η - 1),        N4 = 4 ξ zeta,
  N5 = 4 ξ η,              N6 = 4 η zeta
  ```
  （節点番号 1〜3 が頂点、4〜6 が辺中点）
- **偏微分**: T6 は 2 次形状関数のため、`∂Ni/∂ξ` と `∂Ni/∂η` は 1 次式になる。これをヤコビアンで変換すると `∂Ni/∂x`, `∂Ni/∂y` が得られ、B マトリクス構築に利用できる。
- **ガウス積分**: 2 次要素は 3 点積分（重み 1/6）で正確な結果が得られる。FEM4C では `g_t6_gauss_points` と `g_t6_gauss_weights` に 3 点が定義されている。

#### 簡易図: T6 要素の節点番号
```
        η軸↑
             N3 (節点3)
             *
            / \
        N6 *   * N5
          /     \
         /       \
 N1 (節点1)*--*--* N2 (節点2)
             N4
             → ξ軸
```
3 つの頂点節点 (N1,N2,N3) の間に、辺中点節点 (N4,N5,N6) が配置される。各節点の面積座標 `L1, L2, L3` によって `N4 = 4 L1 L2` などの 2 次形状関数が得られる。

### MATLAB 演習
1. Chapter 03 の T3 実装を拡張し、上記の T6 形状関数を Symbolic で定義して偏微分を求める。
2. 節点座標を `[(0,0); (1,0); (0,1); (0.5,0); (0.5,0.5); (0,0.5)]` として、各ガウス点で `J`, `detJ`, `dN/dx`, `dN/dy` を計算し表にまとめる。
3. MATLAB で 3 点ガウス積分を実装し、`Ke_t6 = Σ B.'*D*B*detJ*weight` を求める。T3 と同様に数値比較用の表を作成する。

### C 言語演習（ヒント付き）
1. **形状関数・偏微分**: `practice/ch07/t6_shape.c` の `t6_shape_functions` と `t6_shape_derivatives_natural` を読み、導出過程を自分のノートに整理する。
2. **ヤコビアン・グローバル偏微分**: 同ファイルの `t6_shape_derivatives_global` をトレースし、6 節点用の `J` と `dN/dx`, `dN/dy` の計算を確認する。@HINT: 配列サイズに注意（6 節点 → 12 DOF）。
3. **B マトリクス確認**: `practice/ch07` のコードを基に `B` を組み立て、MATLAB 表と比較するテストコードを追加する。
4. ガウス点ループを実装し、各点で `B`, `detJ`, `w` を表示するデバッグモードを用意する。FEM4C のログと照らし合わせて理解を深める。
5. 簡易図の節点番号を利用して、辺中点節点の面積座標 `(L1,L2,L3)` を自分で計算し、`N4=4L1L2` などが図と一致することを確認する。

### 検証課題
- T6 要素の B マトリクスを MATLAB と C で比較し、最大誤差が 1e-9 以下になることを確認。
- ガウス点と重みが 1/6 であることを C 実装で確認し、旧版で 1/3 になっていた場合の誤差を計算する。
- detJ が負になるケースを故意に作り、エラーメッセージや警告を出せるようにする。
- 簡易図をもとに節点番号を入れ替えたスケッチを作り、面内の中間節点がどのように並ぶと detJ が負になるかを考察する。

### 応用例
- T3 と T6 の形状関数を比較し、節点値がどのように補間されるかグラフ化する。
- T6 の節点値から滑らかな変位プロットを生成する Python スクリプトを作成し、可視化の精度向上を体験する。

### FEM4C を読む
- `src/elements/t6/t6_element.c` の `t6_shape_functions`, `t6_shape_derivatives_natural`, `t6_jacobian_matrix`, `t6_strain_displacement_matrix`。
- 変数名や配列サイズが T3 からどう変わっているか比較する。
### FEM4C を読む
- `src/elements/t6/t6_element.c` の `t6_shape_functions`, `t6_shape_derivatives_natural`, `t6_jacobian_matrix`, `t6_strain_displacement_matrix`。  
- 変数名や配列サイズが T3 からどう変わっているか比較する。

### 検証課題
- T6 の B マトリクスを MATLAB で計算し、C 実装と一致するか確認。  
- ガウス点と重みが正しく 1/6 になっていることを確認する。

### 応用例
- T6 形状関数を使って節点間の曲線変位を描画する。  
- T3 と T6 の変位差を比較し、メッシュ分割効果と要素次数の違いを議論する。

---

<a id="chapter-08"></a>
## Chapter 08. T6 要素の剛性・荷重・検証

### 理論を整理する
- **T6 要素剛性**: `Ke = Σ_{gp=1..3} B^T D B det(J) w_gp * t`。ガウス点が 3 つある点以外は T3 と同じ構造。
- **荷重ベクトル**:
  - 体積力: `f_e = ∫ N^T b det(J) dξ dη` を同じガウス点で評価。
  - 表面（辺）荷重: 辺上の 1 次元ガウス積分を用い、T6 の辺形状関数（3 節点）を利用して節点荷重へ換算。
- **圧力荷重**: 応力ベクトル t を法線方向に作用させ、辺上の節点へ分配する。FEM4C ではトラクション面ごとに座標を取得し、ガウス積分で節点力を計算している。

### MATLAB 演習
1. Chapter 07 で準備した B とガウス点表を使って、T6 要素剛性 `Ke_t6` を MATLAB で計算し保存する。
2. 辺上の 3 節点形状関数（端点 2、中央 1）を定義し、線積分で `fe_edge = ∫ N_edge^T p |J_edge| w ds` を求める。
3. 面積荷重（体積力）を `fe_body = ∫ N^T b det(J) dξ dη` で計算し、自作 C コードの比較用データを作成する。

### C 言語演習（ヒント付き）
1. **T6 剛性マトリクス**: Chapter 04 のコードを拡張し、3 ガウス点で `B^T D B` を累積する。@HINT: ループの中で `Ke += ... * g_t6_gauss_weights[gp] * detJ * thickness`。
2. **体積力の節点化**: `practice/ch08/t6_body_force.c` の実装を確認し、`g_body_force` に相当するベクトルを生成する流れを追う。@HINT: B ではなく形状関数 N を使う点に注意。
3. **表面荷重（圧力）**: 辺 3 節点の形状関数 `N_edge = [s(1-s)/2, 1 - s^2, s(1+s)/2]` を使い、線積分で節点荷重を求める。@HINT: FEM4C の `assembly_apply_pressure_surface` を読みつつ、自分のコードにコメントで式の意味を付ける。
4. MATLAB で得た `Ke_t6`, `fe_body`, `fe_edge` と比較し、最大誤差が許容範囲内か検証するテストを追加。

### 検証課題
- T3 ソルバーと T6 ソルバーで同じ片持ち梁モデルを解析し、理論変位との差が T6 では 1% 以内に収まることを確認する。
- 分布荷重を節点荷重へ換算した結果を合計し、総荷重が元の値（例: 1000 N）と一致するか検証する。
- detJ が小さい要素での剛性計算が数値的に不安定になることをチェックし、要素品質の重要性を復習する。

### 応用例
- T6 を用いた VTK 出力を ParaView で開き、T3 と T6 の変位分布の滑らかさを比較する。
- FEM4C に新しい荷重タイプ（例: 温度荷重）を追加する際の設計メモをまとめる。

### FEM4C を読む
- `src/elements/t6/t6_stiffness.c`（剛性計算）
- `src/solver/assembly.c` の T6 分岐（`ELEMENT_T6` を扱っている箇所）。
### FEM4C を読む
- `src/elements/t6/t6_stiffness.h/.c`（剛性計算）  
- `src/solver/assembly.c` の T6 分岐（`ELEMENT_T6` を扱っている箇所）。

### 検証課題
- T3 ソルバーで使った片持ち梁データを T6 でも解析し、理論値との差が 1% 以内になるか確認。  
- 分布荷重を節点荷重へ換算した結果が総荷重 1000 N になることを再チェック。

### 応用例
- T6 の結果を VTK で可視化し、T3 と T6 の変位分布の滑らかさを比較。  
- T6 部分のコードにコメントを追加し、FEM4C 本体へプルリクエストできるレベルまで理解を深める。

---

<a id="chapter-09"></a>
## Chapter 09. 入力パーサーの実装ガイド

### 理論を整理する
- FEM4C の解析パイプラインは「入力 → 内部メッシュ構築 → 解析 → 出力」。入力フェーズでは以下を担当する。  
  - ファイル形式の自動判別（ネイティブ vs Nastran BULK）。  
  - ノード／要素／材料／拘束／荷重の読込と内部配列への格納。  
  - 外部 ID と内部インデックスを結ぶマップ（`g_*_ids`, `g_*_id_to_index`）の更新。  
- 固定長カード（Nastran）と可変長フォーマット（ネイティブ）の両方を扱うため、**容量確保 → 初期化 → ID マップ更新 → 実データ格納** の順番が極めて重要。  
- ID 初期化の順序を誤ると、CSV 出力で ID が 0 になる／節点参照が壊れるなど重大バグにつながる（2025-10-13 の修正事例参照）。

### 実装タスク（ヒント付き）
1. **全体フローを把握する**  
   - `src/io/input.c` の `input_read_data` を開き、フォーマット検出 → セクション読み込み → 解析情報設定の流れを図にする。  
   - `input_control_t`（`input.h`）で保持しているファイルポインタ、行バッファ、行番号の役割を確認。
2. **容量確保と初期化の順番を再確認**  
   - `globals_reserve_*` → `globals_initialize_*_entry` → `input_validate_map_*` → `g_*` への代入という順番を、ノード・要素・材料それぞれで追跡。  
   - 練習として `practice/ch09/native_probe.c` を作り、`input_read_nodes` の流れを模倣してノード配列へ格納する簡易コードを書く。
3. **ネイティブ形式の解析**  
   - `input_read_nodes`, `input_read_elements`, `input_read_materials` をトレースし、`strtok` ベースでのトークン化とエラーハンドリング（`CHECK_ERROR`）を確認。  
   - `practice/ch09/native_parser.c` を追加し、T3 要素のみを読み込む軽量パーサーを実装して挙動を確かめる。
4. **Nastran BULK 解析**  
   - `input_parse_nastran_grid`, `input_parse_nastran_ctria6`, `input_nastran_finalize_properties` を読み、固定幅カードの切り出しと ID マップ更新の手順を追う。  
   - `practice/ch09/nastran_probe.c` を作り、`GRID` と `CTRIA6` の情報を読み込んで標準出力に出す練習をする。
5. **エラーハンドリングとログ出力**  
   - `fem_error_t` と `error_set` の使い方を復習し、独自エラー文を追加するときのテンプレートを決めておく。  
   - 解析前に `g_num_nodes`, `g_num_elements`, `g_node_ids[0]` など基本統計を `printf` する `--debug-io` オプションを自作するのも良い演習。

### FEM4C を読む
- `src/io/input.c`, `src/io/input.h`：メインパーサーと補助関数の全体像。  
- `docs/06_fem4c_implementation_history.md`：CSV 出力修正や ID 管理に関する履歴と注意事項。  
- `test/data/` や `NastranBalkFile/` の入力例：多様なカード・境界条件の現物を観察。

### 検証課題
- `examples/t6_cantilever_beam.dat` を読み込んだ直後に `g_node_ids[0]`, `g_element_ids[0]` をダンプし、入力ファイルの ID と一致するかを確認。  
- `NastranBalkFile/2Dmesh.dat` の読み込み後、`g_node_id_to_index[188]` など任意 ID の逆引きが期待どおりか `printf` で検証。  
- 解析後の `beam_output.csv` / `nastran_output.csv` を Python で読み込み、`len(row) == 21` と `row[1] == 元のID` をチェックするスクリプトを Chapter 01 の例を発展させて作成。  
- 入力ファイルに意図的に欠損（例: 節点 ID 重複）を入れ、`input_validate_map_*` がエラーを返す様子を観察してログ文を改善する。

### 応用例
- ネイティブ形式に新しいカード（ばね、集中モーメントなど）を追加するときの ToDo リストを作る。  
- Nastran BULK の `PLOAD` を読み取る草案を実装し、`practice/ch09/nastran_probe.c` で正しくパースできるか試す。  
- Python でメッシュを生成 → ネイティブ形式へエクスポート → FEM4C で解析 → CSV を Python で後処理、という自動化スクリプトをワークフロー化する。

### 便利ツール
- `rg "input_" src/io/input.c` で関数一覧を素早く把握。  
- `python -m csv` や `pandas` を使い、CSV フォーマットのズレを CI で検出するミニテストを書く。  
- `gdb` で `input_read_line` にブレークポイントを置き、行番号 (`input->line_number`) がどこで更新されるか確認する。

---

<a id="chapter-10"></a>
## Chapter 10. FEM4C の全体構成と次の一歩

### 理論を整理する
- FEM4C は以下の層で構成される：  
  - **common**: 定数・グローバル・エラー処理  
  - **io**: 入出力  
  - **elements**: 要素実装  
  - **solver**: 組立とソルバ  
  - **analysis**: ワークフロー  
- スカイライン行列と CG ソルバの組み合わせで大規模問題にも対応。

### 実装タスク（ヒント付き）
1. **FEM4C 追跡**  
   - `src/analysis/static.c` を上から順に読み、Chapter 01〜08 の内容がどこで呼ばれているか対応表を作る。  
2. **自作コードを統合**  
   - `practice` で作ったモジュールを 1 つのミニ FEM ソルバにまとめ、`Makefile` を書く。  
   - `@HINT`: FEM4C の `Makefile` を参考に `SRC`, `OBJ`, `TARGET` を定義。

### FEM4C を読む
- `docs/05_handover_notes.md`：今後の拡張ポイント（圧力、バンド行列、ポスト処理、テスト整備など）を把握する。  
- `docs/06_fem4c_implementation_history.md`：最新の解析ログ、CSV 仕様、既知の課題を随時更新。再着手前のブリーフィングとして活用。

### 検証課題
- T3 → T6 の移行で理解した差分を表にまとめる。  
- FEM4C の T6 解析と自作 T6 実装（簡易版）の結果を比較し、差異があれば原因を調べる。

### 応用例
- 分布荷重、温度荷重、ばね境界など、新しい条件を自作コードで試す。  
- FEM4C に新しい要素（例: Q8）を追加する草案を作成。  
- Nastran BULK（例: `NastranBalkFile/2Dmesh.dat`）を読み込ませ、`nastran_output.csv` が `beam_output.csv` と同じ 21 列構成で出力されるか確認する。異常時は Chapter 01 の Python 検証スニペットで列ズレを特定する。

---

<a id="appendix"></a>
## 付録

### A. 学習チェックリスト
| 章 | 理解度自己確認 |
|----|----------------|
| 01 | FEM4C のビルドと実行ができる |
| 02 | Π 最小原理から Kd=f を説明できる |
| 03 | T3 形状関数・ヤコビアンを実装できる |
| 04 | T3 要素剛性を C で計算できる |
| 05 | 全体剛性の組立と BC 適用を実装できる |
| 06 | CG ソルバと T3 解析を完走できる |
| 07 | T6 形状関数とヤコビアンを説明できる |
| 08 | T6 要素剛性・荷重を計算し検証できる |
| 09 | 入力パーサーの読み込みフローを説明できる |
| 10 | FEM4C の各層の役割を説明できる |

Chapter 03・05・07 のチェックでは、本文に挿入した簡易図を参照しながら節点配置や DOF 対応を口頭で説明できるかを確認すると理解が深まる。

### B. ハンズオンラボ・サンプルコード
`practice/` ディレクトリに各章のハンズオンコードとテストドライバを配置している。本文のサイクル（理論→実装→FEM4C確認→検証）を一巡したら、`practice/README.md` を参照しながらサンプルを実行・改造して理解を深めよう。

- `ch01`〜`ch08`: Chapter 01〜08 の演習と 1:1 で対応するミニプログラム。
- 各 `main` 関数に簡易テストと実行例を同梱しているので、`gcc -Wall -Wextra path/to/file.c -lm` でビルドして挙動を確認する。
- 追加の Python スクリプトや実験コードが増えた場合も `practice/` 以下にまとめておくと、学習者が迷わずアクセスできる。
- 特に `practice/ch03`, `ch05`, `ch07` の実装は章内の簡易図と合わせて確認すると、節点番号や自由度マッピングの意図が把握しやすい。

### C. 追加資料・旧ドキュメントの活用
- `docs/01_requirements.md`: 教科書で扱う解析範囲を俯瞰。新しい題材を検討するときの出発点。
- `docs/05_handover_notes.md`: 圧力荷重、行列ストレージ、ポスト処理など拡張アイデアを整理。次のステップを決める際に参照。
- `docs/RELEASE_README.md`: リリース時のフォルダ構成と配布物の説明。学習用データをどこに置くか迷ったら確認する。
- 旧版の `FEM_LEARNING_GUIDE.md` は、MATLAB 側の観点を補完するリファレンスとして活用できる。

### D. よくある質問
- **Q. FEM4C のコードをそのまま写経すれば良い？**  
  A. 写経は理解の補助になるが、ここで提示した「理論→ヒント実装→FEM4C参照→検証」のサイクルで理解を深めることが重要。
- **Q. T3 と T6 のどちらを先に取り組むべき？**  
  A. 本マニュアル通り、T3 で骨組みを理解してから T6 へ進むのがおすすめ。  
- **Q. スカイライン行列を使わずに実装しても良い？**  
  A. 練習段階では密行列で構わない。性能を求める段階で FEM4C のスカイライン実装を取り入れると良い。

### E. 参考文献
- Bathe, Klaus-Jürgen: *Finite Element Procedures*.  
- Hughes, Thomas JR: *The Finite Element Method*.  
- 山田貴博: *高性能有限要素法*（FEM4C の原典）。  
- MIT OpenCourseWare: *Finite Element Procedures for Solids and Structures*。

---

**Good luck, and happy finite element coding!**  
このマニュアルを一巡したら、FEM4C のコードを「読む」「書く」「改造する」のいずれも自信を持ってこなせるはずである。引き続き、理論と実装を両輪として学習を進めていこう。
