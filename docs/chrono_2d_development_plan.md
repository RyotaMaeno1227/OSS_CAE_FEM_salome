# chrono-C 2D 機能拡張ロードマップ

本ドキュメントは `chrono-C-all` における 2D 機能を Chrono C++ 本家のカバレッジへ近づけるための設計指針と進捗管理をまとめたものです。以降、作業が進むたびにこのファイルを更新します。

## 1. ゴール定義
- 2D 剛体・拘束・接触機能を Chrono-main と同等レベルまで移植し、最終的に 2D シミュレーションを `chrono-C-all` 単体で完結できるようにする。
- テスト（単体・回帰）を充実させ、将来の改修によるリグレッションを防止する。
- 最小限のインフラ（Makefile、CI スクリプト）で自動テストを回せる体制を整え、開発効率を確保する。

## 2. 現状サマリ（2025-10-19 時点）
| 領域 | ステータス | 備考 |
|------|------------|------|
| 剛体基盤 (`chrono_body2d`) | ✅ 初期機能あり | 明示的オイラー積分、ワールド/ローカル変換、円形形状、材料パラメータ（反発・摩擦）対応済み。スリープや多形状未対応。 |
| 距離制約 (`chrono_constraint2d`) | ✅ 安定化 solver あり | Baumgarte + Softness + Warm-start。複数制約や角速度連成未実装。 |
| 接触 (`chrono_collision2d`) | ✅ 円vs円（反発＋静/動摩擦＋2点マニフォールド） | 複数接触の完全管理や持続解決は今後の課題。位置補正は単純。 |
| テスト | ⚠️ 部分的 | 距離拘束収束テスト、円衝突回帰テスト（正面・斜め・静止・摩擦）を整備済み。継続接触や複数接触は未整備。 |
| ドキュメント | ⚠️ 一部整備 | README に単体テストの手順あり。本ドキュメントを起点に設計情報を蓄積。 |

## 3. 機能拡張ロードマップ
### 3.1 剛体
1. **質量特性拡張**  
   - 慣性テンソル更新ロジック（2D 版）を追加し、任意形状に対応できるようにする。  
   - `chrono_body2d_set_mass_properties` の実装とテスト。
2. **積分器拡張**  
   - セミインプリシット・サブステップなどを導入。`chrono_body2d_integrate_semi_implicit` 等の API を検討。
3. **スリープ/ウェイク管理**  
   - 速度閾値と時間閾値を導入し、アイドルなボディを休止状態へ移行。

### 3.2 拘束
1. **抽象インターフェース化**  
   - `ChronoConstraint2DInterface`（関数テーブル）を追加し、複数拘束を扱えるよう統合管理。  
   - **設計メモ（2025-10-19 更新）**  
     - 共通構造体 `ChronoConstraint2DOps_C` に `prepare`, `warm_start`, `solve_velocity`, `solve_position` の関数ポインタを保持。  
     - ボディ参照やアンカーポイントなどの共有データを `ChronoConstraint2DBase_C` にまとめ、各拘束型はこれを先頭メンバとして含む。  
     - 初期化関数で ops を設定し、既存 API (`chrono_distance_constraint2d_prepare` 等) は ops 呼び出しに委譲する薄いラッパーへ移行して後方互換を維持。  
     - 拘束配列を処理する `chrono_constraint2d_batch_solve(...)` を追加し、Sequential Impulse 風に反復できるよう設計。  
     - 将来的な並列化を見据え、バッチ構造には拘束グループ ID（アイランド）を保持できる拡張余地を残す。
2. **新規拘束タイプ**  
   - 回転ジョイント（ピン）、スライダ、スプリングダンパ等を段階的に追加。
3. **ソルバー**  
   - Sequential Impulse / Gauss-Seidel による複合拘束解決。  
   - Baumgarte 以外の安定化手法（位置校正、XPBD 的アプローチ）の検討。

### 3.3 接触
1. **接線摩擦・接線方向インパルス**  
   - クーロン摩擦モデルの実装と回帰テスト。  
   - スリープ解除や粘着処理フラグの検討。
   - ボディ単位での摩擦・反発係数設定APIを提供し、接触毎に組み合わせた係数を利用。
2. **継続接触管理**  
   - マンifold（複数接触点）の保持、ウォームスタート用蓄積インパルス管理。
3. **形状拡張**  
   - 凸ポリゴン対応：SAT or GJK/EPA の簡易実装。  
   - 円 vs ポリゴン、ボックス vs ボックスなどをサポート。
4. **アイランドソルバーの導入**  
   - 拘束・接触をまとめたアイランド分割と並列実行への布石。

### 3.4 テスト & ツール
1. **単体テスト整備**  
   - 各拘束・接触ケースの数値回帰テストを `tests/` 以下に追加。  
   - `make test` で全テストが実行されるよう連携。
2. **ベンチマーク/デモ**  
   - パフォーマンス検証用のベンチスイートを整備し、改善効果を把握。
3. **CI 連携**  
   - GitHub Actions 等でテスト自動実行（ローカルでの再現性重視、後日CI環境を検討）。

## 4. マイルストンとタスク一覧
| フェーズ | 想定期間 | 主タスク | 成果物 | 進捗 |
|----------|----------|----------|----------|------|
| Phase 1: テスト基盤強化 | 1-2 週間 | 既存テスト拡張、`make test` 整備、リグレッションテスト追加 | テストスイート、ログ | ✅ （正面/斜め/静止/摩擦の接触テストを整備済み） |
| Phase 2: 拘束インターフェース化 | 2-3 週間 | 距離拘束の共通化、ピンジョイント追加 | `chrono_constraint2d` 拡張、テスト | ⏳ （ops テーブル導入済み。複数拘束処理と新拘束追加が未実装） |
| Phase 3: 接触摩擦対応 | 2-3 週間 | 接触摩擦、接線方向処理、接触継続管理 | `chrono_collision2d` 拡張、回帰テスト | ⏳ |
| Phase 4: 形状/ソルバー強化 | 3-4 週間 | 凸形状衝突、Sequential Impulse、アイランド処理 | 拘束/接触統合ソルバー | ⏳ |
| Phase 5: 最終統合・ドキュメント | 1-2 週間 | ドキュメント整備、ベンチ、CI 準備 | README 更新、設計ドキュメント | ⏳ |

## 5. 進捗トラッキング
- **最新更新日**: 2025-10-19
- **完了済みハイライト**
- 明示的距離拘束テスト (`test_distance_constraint_stabilization`) 自動化。
- 円衝突回帰テスト (`test_circle_collision_regression`) 追加。
- 円衝突斜め回帰テスト (`test_circle_collision_oblique`) 追加し、摩擦ゼロ時の接線速度保存を検証。
- 円衝突静止回帰テスト (`test_circle_collision_resting`) 追加し、ゼロ相対速度での安定性を確認。
- 円衝突摩擦回帰テスト (`test_circle_collision_friction`) を追加し、静摩擦保持と動摩擦減速、マンifoldウォームスタートを確認。
- 円衝突摩擦回帰テスト (`test_circle_collision_friction`) を追加し、静摩擦保持と動摩擦減速、マネージャ経由でのマニフォールドウォームスタートを確認。
- マテリアル組み合わせテスト (`test_circle_collision_materials`) を追加し、ボディごとの係数設定が期待どおり合成されることを解析解と比較して確認。
- 拘束フレームワークに `ChronoConstraint2DOps_C`/`ChronoConstraint2DBase_C` を導入し、距離拘束を新インターフェースへ移行。
- 距離拘束バッチソルバ (`chrono_constraint2d_batch_solve`) と OpenMP ベースの SMP 対応を実装し、`test_constraint_batch_solve` で並列／直列の一致を検証。
  - アイランド分割を Union-Find＋ハッシュマップベースに刷新し、大規模拘束でも高速にグルーピング可能にした。
- **次のアクション候補**
  1. 摩擦付き接触での複数接触点・マンifold拡張（複数点、永続性）を検討し、継続接触の安定化を図る。
  2. ボディ/素材ごとの摩擦係数設定APIを検討し、テストを拡張（複数組み合わせ）。

## 9. バッチソルバ最適化メモ（2025-10-19）
- 目的: `chrono_constraint2d_batch_solve` 内で繰り返し確保している中間配列（アイランドID、サイズ、オフセット、並び替えバッファなど）を再利用可能なワークスペースに移し、ヒープ割り当てコストと断片化を低減する。
- 方針:
  - `ChronoConstraint2DBatchWorkspace_C` を導入し、必要バッファと現在容量を保持。
  - API: `chrono_constraint2d_workspace_init`, `chrono_constraint2d_workspace_reserve`, `chrono_constraint2d_workspace_reset`, `chrono_constraint2d_workspace_free` を提供。
  - バッチソルバはワークスペースが指定された場合それを利用し、NULL の場合は従来どおり内部で一時バッファを確保するフォールバックを用意。
  - テストではワークスペース有無双方で挙動が変わらないことを検証する。
- 利用例（シミュレーションループ）:
  ```c
  ChronoConstraint2DBatchWorkspace_C workspace;
  chrono_constraint2d_workspace_init(&workspace);

  while (running) {
      chrono_constraint2d_workspace_reset(&workspace);
      chrono_constraint2d_batch_solve(constraints,
                                      constraint_count,
                                      dt,
                                      &batch_cfg,
                                      &workspace);
      // その他のステップ処理...
  }

  chrono_constraint2d_workspace_free(&workspace);
  ```

## 10. 摩擦導入テスト設計（初版）
- 目的: 円同士の接触に静摩擦・動摩擦を導入する際の挙動を検証し、将来の接線方向処理に備える。
- 想定シナリオ
  | ケース | 内容 | 期待挙動 | 備考 |
  |-------|------|---------|------|
  | 静止接触保持 | 接触面で相対速度 0、摩擦係数高 | 接線方向速度が発生せず静止維持 | 静摩擦閾値テスト |
  | 静摩擦崩壊 | 接線方向力が静摩擦を超える | 滑り始め、動摩擦係数に基づく減速 | 閾値付近での分岐確認 |
  | 斜め衝突滑り | 初速度に接線成分あり | 反発＋接線減速（動摩擦） | 既存斜め衝突テスト拡張 |
  | 継続接触 | 連続タイムステップで接触継続 | 摩擦インパルスの蓄積・解放を検証 | アイランド分割の影響確認 |
- テスト実装メモ:
  - 既存 `test_circle_collision_*` シリーズを拡張し、摩擦係数と接線方向の目標値を追加。
  - 静摩擦 vs 動摩擦の閾値比較用にサンプル力（もしくは接線速度）を設定。
  - 将来的なウォームスタートや接触継続処理と相性を確認するため、連続ステップのログ/チェックを導入。
  - `ChronoContactManifold2D_C` を用意し、接触ごとの法線・接線インパルスを蓄積してウォームスタートできるようにした。
  - `ChronoContactManager2D_C` でボディペアごとのマニフォールドを管理し、最大2接触点の継続・ウォームスタートを扱えるようにした。

## 6. 参考資料・メモ
- Chrono-main (C++) の関連ソース：`ChBody`, `ChLink`, `ChContactContainer` 等
- 既存の 3D 実装を参考にする際は、データ構造と API レイヤに差異があるため抽象化設計を先に行うこと。
- 接触摩擦導入時は数値発散を避けるため、テストを細分化しベータ版段階での回帰テストを徹底する。

## 7. SMP 対応方針（初版）
- 目標: 拘束・接触処理のうちデータ依存性の低い部分を OpenMP を用いた並列化で高速化。
- 当面の対象: 距離拘束のバッチ解法 (`chrono_constraint2d_batch_solve`) をマルチスレッド化し、複数拘束を独立に処理できるケースで並列実行する。
- 設計メモ:
  - 依存関係のある拘束同士は同一スレッド／シリアル処理とし、将来的なアイランド分割アルゴリズム導入で並列性を向上させる。
  - OpenMP セクションを利用し、`#pragma omp parallel for` で拘束配列を処理。
  - テストでは OpenMP を有効にしたビルドで結果がシリアル実装と一致することを確認。
  - Makefile に `-fopenmp` フラグを追加し、環境変数 `OMP_NUM_THREADS`で制御可能とする。

## 8. アイランド分割計画（新規）
- 目的: ボディが共通する拘束同士を同じ「アイランド」としてグループ化し、並列ソルバ実行時のデータ競合を避ける。
- 初期実装案:
  - 入力: `ChronoConstraint2DBase_C*` 配列と件数。
  - Union-Find または BFS を用いて、共有ボディを介して連結な拘束を同じアイランドへ割り当てる。
  - 出力: アイランド配列（開始インデックス＋サイズ）または各拘束のアイランドID。
  - 既存バッチソルバはアイランド単位で逐次実行し、`enable_parallel` が真の場合はアイランド間を並列化する。
- テスト計画:
  - 3 本の拘束でアイランド数が 2 になるケースを用意し、ビルドしたアイランド情報が期待通りか確認。
  - 並列実行でアイランド単位にスケジュールされるかどうかをログまたは結果の一致で検証。

---
※ 本ドキュメントは進捗に応じて逐次更新します。更新時は「最新更新日」と該当セクションの内容を明確に変更してください。
